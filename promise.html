<!DOCTYPE html>
<html>
<head>
	<title>简陋promise</title>
</head>
<body>
</body>
<script>
function myPromise(callback){
	var self = this;
	self.status = 'pending';
	self.data = undefined;
	self.onResolvedCallback = [];
	self.onRejectCallback = [];

	function resolve(value) {
		if(self.status === 'pending') {
			self.status = 'resolved';
			self.data = value;
			for(var i = 0; i < self.onResolvedCallback.length; i ++) {
				self.onResolvedCallback[i](value);
			}
		}
	}

	function reject(value) {
		if(self.status === 'pending') {
			self.status = 'rejected';
			self.data = value;
			for(var i = 0; i < self.onRejectCallback.length; i ++) {
				self.onRejectCallback[i](value);
			}
		}
	}
	callback(resolve,reject);
}

myPromise.prototype.then = function(onResolved,onRejected) {
	var self = this;
	onResolved = (typeof onResolved === "function") : onResolved ? function(v){};
	onRejected = (typeof onRejected === "function") : onRejected ? function(v){};

	if(self.status === "resolved") {
		return new myPromise(function(resolve,reject){
			try {
		        var x = onResolved(self.data)
		        if (x instanceof myPromise) { // 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果
		          x.then(resolve, reject)
		        }
		        resolve(x) // 否则，以它的返回值做为promise2的结果
		      } catch (e) {
		        reject(e) // 如果出错，以捕获到的错误做为promise2的结果
		      }
		});
	}

	if(self.status === "rejected") {
		return new myPromise(function(resolve,reject){
			try {
		        var x = onResolved(self.data)
		        if (x instanceof myPromise) { // 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果
		          x.then(resolve, reject)
		        }
		        resolve(x) // 否则，以它的返回值做为promise2的结果
		      } catch (e) {
		        reject(e) // 如果出错，以捕获到的错误做为promise2的结果
		      }
		});
	}

	if(self.status === "pending") {
		return new myPromise(function(resolve,reject){
			self.onResolvedCallback.push(function(value){
				try {
			        var x = onResolved(self.data)
			        if (x instanceof myPromise) { // 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果
			          x.then(resolve, reject)
			        }
			        resolve(x) // 否则，以它的返回值做为promise2的结果
			      } catch (e) {
			        reject(e) // 如果出错，以捕获到的错误做为promise2的结果
			      }
			});

			self.onRejectedCallback.push(function(value){
				try {
			        var x = onRejected(self.data)
			        if (x instanceof myPromise) { // 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果
			          x.then(resolve, reject)
			        }
			        resolve(x) // 否则，以它的返回值做为promise2的结果
			      } catch (e) {
			        reject(e) // 如果出错，以捕获到的错误做为promise2的结果
			      }
			});
	}
}
// function myPromise(callback){
// 	this.status = 'pending',
// 	this.val = undefined;
// 	this.cb = [];
// 	return function(res,rej){
// 		this.cb.push({
// 			resolve : res,
// 			reject :rej
// 		})	
// 		return callback(res,rej);
// 	}
// }

// myPromise.prototype = {
// 	constructor : myPromise,
// 	resolve : function() {
// 		this.status = 'resolve';
// 		complete(this.val);
// 	},
// 	reject : function() {
// 		this.status = 'reject';
// 		complete(this.val);
// 	},
// 	complete : function() {
// 		while(this.cb[0][this.status]){
// 			this.val = this.cb.shift()[status]();
// 		}
// 	},
// 	then : function() {
// 		complete();
// 		return this;
// 	}
// }

// function res(){
// 	console.log('resolve');
// }

// function rej(){
// 	console.log('reject');
// }

var p1 = new myPromise(function(res,rej){
	console.log(123);
}).then(function(){
	console.log('hhhh');
},function(){
	console.log('xxxx');
});
// new Promise(function(resolve,reject){
// 		//....
// }).then();
</script>
</html>